name: Deploy AWS Inspector Lambda Function.

on:
  push:
    branches: [main]
  
  workflow_dispatch:

env:
  AWS_REGION: eu-west-2
  LAMBDA_NAME: lambda-deployment
  LAMBDA_RUNTIME: python3.12
  LAMBDA_TIMEOUT: 300  # 5 minutes
  LAMBDA_MEMORY: 256   # MB
  FUNCTION_NAME: inspector-ec2-scanner

jobs:
  deploy-lambda:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC }}
          role-session-name: LambdaDeploymentSession
          aws-region: ${{ env.AWS_REGION }}

      - name: Create Lambda Deployment Package
        id: create_package
        run: |
          echo "üì¶ Creating Lambda deployment package..."

          # Set package name
          PACKAGE_NAME="lambda-deployment.zip"
          
          # Create deployment directory
          mkdir -p lambda-package

          # Create requirements.txt
          cat > requirements.txt << 'DEPS'
          weasyprint==60.2
          DEPS
          
          # Install dependencies
          pip install -r requirements.txt -t lambda-package/
          
          # Create the Python script inline
          cat > lambda-package/lambda_function.py << 'EOF'
          import json, boto3, os, base64
          from datetime import datetime, timezone

          SNS_TOPIC_ARN = os.environ["SNS_TOPIC_ARN"]
          SCAN_TYPE = os.environ.get("SCAN_TYPE", "PACKAGE_VULNERABILITY")
          ENVIRONMENT_FILTER = os.environ.get("ENVIRONMENT_FILTER", "")
          REPORTS_BUCKET = os.environ.get("REPORTS_BUCKET", "inspector-reports-bucket")

          sns = boto3.client("sns")
          ec2 = boto3.client("ec2")
          inspector2 = boto3.client("inspector2")

          def _get_ec2_name_map(instance_ids):
              """
              Returns a dict mapping instance-id ‚Üí Name-tag (or 'Unnamed Instance').
              """
              if not instance_ids:
                  return {}

              resp = ec2.describe_instances(InstanceIds=instance_ids)
              name_map = {}

              for reservation in resp.get("Reservations", []):
                  for instance in reservation.get("Instances", []):
                      iid  = instance["InstanceId"]
                      tags = instance.get("Tags", [])
                      name = next((t["Value"] for t in tags if t["Key"] == "Name"), None)
                      name_map[iid] = name or "Unnamed Instance"

              return name_map

          def _discover_running_instances():
              """Get all running EC2 instances, optionally filtered by environment."""
              filters = [{"Name": "instance-state-name", "Values": ["running"]}]
              
              if ENVIRONMENT_FILTER:
                  filters.append({"Name": "tag:Environment", "Values": [ENVIRONMENT_FILTER]})
              
              resp = ec2.describe_instances(Filters=filters)
              
              instances = []
              for reservation in resp.get("Reservations", []):
                  for instance in reservation.get("Instances", []):
                      instances.append(instance["InstanceId"])
              
              print(f"üìã Found {len(instances)} running instances")
              return instances

          def _get_sbom_findings(instance_ids):
              """Retrieve SBOM and findings data from Inspector V2."""
              try:
                  findings_response = inspector2.list_findings(
                      filterCriteria={
                          'resourceId': [{'comparison': 'EQUALS', 'value': iid} for iid in instance_ids]
                      },
                      maxResults=50
                  )
                  
                  findings = findings_response.get('findings', [])
                  print(f"üìä Retrieved {len(findings)} findings for SBOM report")
                  
                  return {
                      'findings': findings,
                      'instance_count': len(instance_ids)
                  }
                  
              except Exception as e:
                  print(f"‚ö†Ô∏è Error retrieving Inspector data: {str(e)}")
                  return {'findings': [], 'instance_count': len(instance_ids)}

          def _upload_pdf_to_s3(pdf_data, scan_name):
              """Upload PDF report to S3 bucket."""
              try:
                  s3_client = boto3.client('s3')
                  timestamp = datetime.now(timezone.utc).strftime('%Y/%m/%d')
                  s3_key = f"inspector-reports/{timestamp}/{scan_name}.pdf"
                  
                  s3_client.put_object(
                      Bucket=REPORTS_BUCKET,
                      Key=s3_key,
                      Body=pdf_data,
                      ContentType='application/pdf',
                      Metadata={'scan-name': scan_name, 'generated-at': datetime.now(timezone.utc).isoformat()}
                  )
                  
                  pdf_url = s3_client.generate_presigned_url(
                      'get_object',
                      Params={'Bucket': REPORTS_BUCKET, 'Key': s3_key},
                      ExpiresIn=86400
                  )
                  
                  print(f"‚úÖ PDF uploaded to S3: s3://{REPORTS_BUCKET}/{s3_key}")
                  return pdf_url
                  
              except Exception as e:
                  print(f"‚ö†Ô∏è Could not upload PDF to S3: {str(e)}")
                  return None

          def _create_inspector_scan(instance_ids):
              """Enable Inspector V2 scanning and generate SBOM PDF."""
              scan_name = f"ec2-scan-{datetime.now(timezone.utc).strftime('%Y%m%d-%H%M')}"
              
              try:
                  sts_client = boto3.client('sts')
                  account_id = sts_client.get_caller_identity()['Account']
                  
                  response = inspector2.batch_get_account_status(accountIds=[account_id])
                  account_status = response.get('accounts', [])
                  
                  if account_status and account_status[0].get('state', {}).get('status') == 'ENABLED':
                      print(f"‚úÖ Inspector V2 is enabled for account {account_id}")
                      
                      # Get SBOM and findings data
                      print("üìä Retrieving SBOM and findings data...")
                      findings_data = _get_sbom_findings(instance_ids)
                      
                      # Generate clean PDF report
                      print("üìÑ Generating clean, filtered PDF report...")
                      pdf_data = _generate_clean_pdf(f"inspector-v2-{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S')}", scan_name, instance_ids, findings_data)
                      
                      # Upload PDF to S3
                      pdf_url = _upload_pdf_to_s3(pdf_data, scan_name)
                      
                      scan_id = f"inspector-v2-{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S')}"
                      print(f"‚úÖ Inspector V2 scanning completed with PDF report")
                      print(f"üìÑ PDF report generated: {len(pdf_data)} bytes")
                      
                      return scan_id, scan_name, pdf_url
                      
                  else:
                      print("‚ö†Ô∏è Inspector V2 not enabled - enabling now...")
                      inspector2.enable(resourceTypes=['EC2'])
                      scan_id = f"enabled-{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S')}"
                      print(f"‚úÖ Inspector V2 enabled and scanning {len(instance_ids)} instances")
                      return scan_id, scan_name, None
                      
              except Exception as e:
                  print(f"‚ö†Ô∏è Inspector V2 setup error: {str(e)}")
                  print(f"üìã Proceeding with instance validation for {len(instance_ids)} instances")
                  scan_id = f"validated-{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S')}"
                  return scan_id, scan_name, None    

          def _filter_critical_findings(findings_data):
              """Filter and prioritize findings for concise PDF report."""
              
              findings = findings_data.get('findings', [])
              
              # Priority filtering: Critical > High > Medium (exclude Low for brevity)
              critical_findings = [f for f in findings if f.get('severity') == 'CRITICAL']
              high_findings = [f for f in findings if f.get('severity') == 'HIGH']
              medium_findings = [f for f in findings if f.get('severity') == 'MEDIUM']
              
              # Limit findings for readability (max 8 total)
              filtered_findings = []
              filtered_findings.extend(critical_findings[:4])  # Max 4 critical
              filtered_findings.extend(high_findings[:3])      # Max 3 high
              filtered_findings.extend(medium_findings[:1])    # Max 1 medium
              
              return {
                  'priority_findings': filtered_findings,
                  'total_critical': len(critical_findings),
                  'total_high': len(high_findings),
                  'total_medium': len(medium_findings),
                  'total_low': len([f for f in findings if f.get('severity') == 'LOW']),
                  'total_findings': len(findings)
              }

          def _generate_clean_pdf(scan_id, scan_name, instance_ids, findings_data):
              """Generate clean, readable PDF with filtered vital information only."""
              
              # Filter findings for concise report
              filtered = _filter_critical_findings(findings_data)
              priority_findings = filtered['priority_findings']
              
              # Get instance names for summary
              instance_names = []
              try:
                  name_map = _get_ec2_name_map(instance_ids)
                  instance_names = [f"{name_map.get(iid, 'Unnamed')}" for iid in instance_ids[:3]]
                  if len(instance_ids) > 3:
                      instance_names.append(f"... and {len(instance_ids)-3} more")
              except:
                  instance_names = [f"Instance {i+1}" for i in range(min(len(instance_ids), 3))]
              
              # Risk assessment
              risk_level = "üî¥ HIGH RISK" if filtered['total_critical'] > 0 else \
                          "üü† MEDIUM RISK" if filtered['total_high'] > 0 else \
                          "üü° LOW RISK" if filtered['total_medium'] > 0 else \
                          "üü¢ MINIMAL RISK"
              
              # Generate priority findings HTML (only most important)
              priority_findings_html = ""
              for i, finding in enumerate(priority_findings, 1):
                  severity = finding.get('severity', 'UNKNOWN')
                  severity_colors = {
                      'CRITICAL': '#dc3545', 'HIGH': '#fd7e14', 
                      'MEDIUM': '#ffc107', 'LOW': '#28a745'
                  }
                  color = severity_colors.get(severity, '#6c757d')
                  
                  # Extract key CVE/vulnerability info
                  title = finding.get('title', 'Security Issue')[:50]
                  vuln_id = ''
                  if 'packageVulnerabilityDetails' in finding:
                      vuln_id = finding['packageVulnerabilityDetails'].get('vulnerabilityId', '')
                  
                  # Get affected resource (simplified)
                  resources = finding.get('resources', [])
                  affected_resource = resources[0].get('id', 'Unknown') if resources else 'Unknown'
                  
                  priority_findings_html += f"""
                  <div style="margin: 10px 0; padding: 15px; border-left: 5px solid {color}; background: #f8f9fa; border-radius: 5px;">
                      <div style="display: flex; justify-content: space-between; align-items: center;">
                          <h4 style="margin: 0; color: #333;">{i}. {title}</h4>
                          <span style="background: {color}; color: white; padding: 4px 8px; border-radius: 3px; font-size: 12px; font-weight: bold;">{severity}</span>
                      </div>
                      <p style="margin: 8px 0 4px 0; color: #666;"><strong>Affected:</strong> {affected_resource}</p>
                      {f'<p style="margin: 4px 0; color: #666;"><strong>CVE:</strong> {vuln_id}</p>' if vuln_id else ''}
                      <p style="margin: 4px 0; color: #555; font-size: 14px;">{finding.get("description", "No description available")[:120]}...</p>
                  </div>
                  """
              
              # Define reusable CSS variables and simplified styles
              css_styles = """
                  body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; color: #333; }
                  .header { background: #2a5298; color: white; padding: 20px; border-radius: 8px; text-align: center; margin-bottom: 20px; }
                  .summary-box { background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0; }
                  .metrics { display: flex; gap: 10px; margin: 15px 0; }
                  .metric { text-align: center; padding: 10px; background: white; border: 2px solid #ddd; border-radius: 5px; flex: 1; }
                  .critical { border-color: #dc3545; } .high { border-color: #fd7e14; } .medium { border-color: #ffc107; }
                  .finding { margin: 10px 0; padding: 10px; border-left: 4px solid #ddd; background: #f8f9fa; }
              """

              html_content = f"""<!DOCTYPE html>
              <html><head><meta charset="UTF-8"><title>AWS Inspector Report</title>
              <style>{css_styles}</style></head><body>"""
              <body>
                  <div class="header">
                      <h1>üõ°Ô∏è AWS Inspector Security Report</h1>
                      <p>Executive Summary - Priority Issues Only</p>
                  </div>
                  
                  <div class="summary-grid">
                      <div class="summary-box">
                          <h3 style="margin: 0 0 15px 0; color: #495057;">üìã Scan Details</h3>
                          <table>
                              <tr><td class="label">Scan ID:</td><td>{scan_id}</td></tr>
                              <tr><td class="label">Date:</td><td>{datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}</td></tr>
                              <tr><td class="label">Instances:</td><td>{len(instance_ids)} ({', '.join(instance_names)})</td></tr>
                              <tr><td class="label">Total Issues:</td><td>{filtered['total_findings']}</td></tr>
                          </table>
                      </div>
                      
                      <div class="summary-box">
                          <h3 style="margin: 0 0 15px 0; color: #495057;">‚ö†Ô∏è Risk Assessment</h3>
                          <div class="risk-level">{risk_level}</div>
                          <p style="font-size: 14px; text-align: center; margin: 10px 0 0 0; color: #666;">
                              {"Immediate action required" if filtered['total_critical'] > 0 else 
                              "Review and plan remediation" if filtered['total_high'] > 0 else 
                              "Monitor and address when convenient" if filtered['total_medium'] > 0 else 
                              "No immediate action needed"}
                          </p>
                      </div>
                  </div>
                  
                  <div class="metrics">
                      <div class="metric critical">
                          <h3 class="metric-value" style="color: #dc3545;">{filtered['total_critical']}</h3>
                          <p class="metric-label">Critical</p>
                      </div>
                      <div class="metric high">
                          <h3 class="metric-value" style="color: #fd7e14;">{filtered['total_high']}</h3>
                          <p class="metric-label">High</p>
                      </div>
                      <div class="metric medium">
                          <h3 class="metric-value" style="color: #ffc107;">{filtered['total_medium']}</h3>
                          <p class="metric-label">Medium</p>
                      </div>
                      <div class="metric">
                          <h3 class="metric-value" style="color: #28a745;">{filtered['total_low']}</h3>
                          <p class="metric-label">Low</p>
                      </div>
                  </div>
                  
                  <div class="findings-section">
                      <h2 class="findings-header">üîç Priority Security Issues (Top {len(priority_findings)})</h2>
                      <div class="findings-content">
                          {priority_findings_html if priority_findings else '<p style="text-align: center; color: #28a745; font-size: 16px;">üéâ No critical security issues detected!</p>'}
                      </div>
                  </div>
                  
                  <div class="footer">
                      <p><strong>Next Steps:</strong> {"1. Address critical issues immediately 2. Review high-priority items 3. Schedule medium-priority fixes" if filtered['total_critical'] + filtered['total_high'] > 0 else "Continue monitoring. No urgent action required."}</p>
                      <p style="font-size: 12px; color: #666; margin-top: 10px;">
                          Report generated by AWS Inspector V2 | Scan ID: {scan_id} | This report shows only the most critical findings for executive review.
                      </p>
                  </div>
              </body>
              </html>
              """
              
              # Convert HTML to PDF with fallback
              try:
                  from weasyprint import HTML
                  pdf_data = HTML(string=html_content).write_pdf()
                  print(f"üìÑ Generated clean PDF report: {len(pdf_data)} bytes")
                  return pdf_data
              except Exception as e:
                  print(f"‚ö†Ô∏è PDF generation failed, using HTML fallback: {str(e)}")
                  # Return HTML as base64 for manual conversion
                  html_bytes = html_content.encode('utf-8')
                  return base64.b64encode(html_bytes).decode('utf-8')

          def _send_scan_notification(scan_id, scan_name, instance_ids, pdf_url=None):
              """Send enhanced notification with PDF link."""
              name_map = _get_ec2_name_map(instance_ids)
              instance_list = [f"{name_map[iid]}: {iid}" for iid in instance_ids]
              
              pdf_section = f"\n\nüìÑ SBOM PDF Report: {pdf_url}" if pdf_url else "\n\nüìÑ PDF report generation in progress..."
              
              message = f"""AWS Inspector V2 scan completed with SBOM analysis.

          Scan: {scan_name}
          ID: {scan_id}
          Type: {SCAN_TYPE}
          Instances: {len(instance_ids)}

          Scanned Instances:
          {chr(10).join(instance_list)}
          {pdf_section}

          Status available in AWS Console."""
              
              sns.publish(
                  TopicArn=SNS_TOPIC_ARN,
                  Subject=f"Inspector SBOM Report - {scan_name}",
                  Message=message
              )
              print("‚úÖ Enhanced notification sent with PDF link")  

          def lambda_handler(event, context):
              """
              Triggered by EventBridge scheduled events or manual invocation.
              Scans EC2 instances using AWS Inspector V2 and sends SNS notification.
              """
              print("‚ñ∂Ô∏é Received event:", json.dumps(event))

              try:
                  # 1. Discover EC2 instances
                  ec2_ids = _discover_running_instances()
                  if not ec2_ids:
                      print("‚ÑπÔ∏é No EC2 instances found")
                      return {"statusCode": 204, "body": "No instances to scan"}

                  # 2. Create Inspector scan and generate PDF
                  result = _create_inspector_scan(ec2_ids)
                  if len(result) == 3:
                      scan_id, scan_name, pdf_url = result
                  else:
                      scan_id, scan_name = result
                      pdf_url = None
                  
                  # 3. Send notification with PDF link
                  _send_scan_notification(scan_id, scan_name, ec2_ids, pdf_url)
                  
                  print("‚úÖ Scan initiated successfully")
                  return {"statusCode": 200, "body": f"Scan started: {scan_id}"}
                  
              except Exception as e:
                  print(f"‚ùå Error: {str(e)}")
                  return {"statusCode": 500, "body": f"Failed: {str(e)}"}
          EOF
          
          # Create ZIP package
          cd lambda-package
          zip -r ../$PACKAGE_NAME .
          cd ..
          
          echo "‚úÖ Package created: $PACKAGE_NAME"

          echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT

      - name: Deploy Lambda Function
        run: |
          FUNCTION_NAME="inspector-ec2-scanner"
          PACKAGE_NAME="${{ steps.create_package.outputs.package_name }}"
          
          echo "üöÄ Deploying Lambda function..."
          
          if aws lambda get-function --function-name $FUNCTION_NAME 2>/dev/null; then
            echo "üîÑ Updating existing function..."
            
            aws lambda update-function-code \
              --function-name $FUNCTION_NAME \
              --zip-file fileb://$PACKAGE_NAME

            # Wait for code update to complete
            echo "‚è≥ Waiting for code update to complete..."
            aws lambda wait function-updated --function-name $FUNCTION_NAME  
            
            aws lambda update-function-configuration \
              --function-name $FUNCTION_NAME \
              --runtime ${{ env.LAMBDA_RUNTIME }} \
              --timeout ${{ env.LAMBDA_TIMEOUT }} \
              --memory-size ${{ env.LAMBDA_MEMORY }} \
              --environment Variables="{SNS_TOPIC_ARN=${{ secrets.SNS_TOPIC_ARN }},SCAN_TYPE=PACKAGE_VULNERABILITY,ENVIRONMENT_FILTER=staging,REPORTS_BUCKET=${{ secrets.REPORTS_BUCKET }}}"
            
            echo "‚úÖ Function updated"
          else
            echo "üÜï Creating new function..."
            
            aws lambda create-function \
              --function-name $FUNCTION_NAME \
              --runtime ${{ env.LAMBDA_RUNTIME }} \
              --role ${{ secrets.LAMBDA_EXECUTION_ROLE_ARN }} \
              --handler lambda_function.lambda_handler \
              --zip-file fileb://$PACKAGE_NAME \
              --timeout ${{ env.LAMBDA_TIMEOUT }} \
              --memory-size ${{ env.LAMBDA_MEMORY }} \
              --environment Variables="{SNS_TOPIC_ARN=${{ secrets.SNS_TOPIC_ARN }},SCAN_TYPE=PACKAGE_VULNERABILITY,ENVIRONMENT_FILTER=staging,REPORTS_BUCKET=${{ secrets.REPORTS_BUCKET }}}" \
              --description "AWS Inspector V2 EC2 Scanner - staging"
            
            echo "‚úÖ Function created"
          fi

      - name: Create EventBridge Schedule (Quarterly - Auto)
        id: create_schedule
        run: |
          SCHEDULE_NAME="inspector-scan-quarterly"
          FUNCTION_NAME="inspector-ec2-scanner"
          
          echo "üìÖ Setting up quarterly EventBridge schedule..."
          
          # Check if rule already exists
          if aws events describe-rule --name $SCHEDULE_NAME 2>/dev/null; then
            echo "‚ÑπÔ∏é Quarterly schedule already exists: $SCHEDULE_NAME"
          else
            echo "üÜï Creating quarterly schedule (auto-enabled)..."
            
            # Get Lambda function ARN
            LAMBDA_ARN=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.FunctionArn' --output text)
            
            # Create schedule (quarterly: January, April, July, October at 2 AM UTC)
            aws events put-rule \
              --name $SCHEDULE_NAME \
              --schedule-expression "cron(0 2 1 1,4,7,10 ? *)" \
              --description "Quarterly AWS Inspector EC2 scan - staging (AUTO)" \
              --state ENABLED
            
            # Add Lambda target
            aws events put-targets \
              --rule $SCHEDULE_NAME \
              --targets "Id"="1","Arn"="$LAMBDA_ARN"
            
            # Add Lambda permission for EventBridge
            aws lambda add-permission \
              --function-name $FUNCTION_NAME \
              --statement-id allow-eventbridge-quarterly \
              --action lambda:InvokeFunction \
              --principal events.amazonaws.com \
              --source-arn "arn:aws:events:${{ env.AWS_REGION }}:$(aws sts get-caller-identity --query Account --output text):rule/$SCHEDULE_NAME" \
              2>/dev/null || echo "Permission already exists"
            
            echo "‚úÖ Quarterly schedule created (ENABLED): $SCHEDULE_NAME"
          fi
          
          echo "schedule_name=$SCHEDULE_NAME" >> $GITHUB_OUTPUT

      - name: Test Lambda Function
        run: |
          echo "üß™ Testing Lambda function..."
          
          aws lambda invoke \
            --function-name inspector-ec2-scanner \
            --payload '{}' \
            response.json
          
          echo "‚úÖ Test invocation sent (async)"
          echo "üìä Check CloudWatch logs: aws logs tail /aws/lambda/inspector-ec2-scanner --follow"

      - name: Upload Deployment Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.LAMBDA_NAME }}
          path: |
            ${{ steps.create_package.outputs.package_name }}
          retention-days: 30

      - name: Deployment Summary
        run: |
          echo "üéâ Deployment completed successfully!"
          echo ""
          echo "üìã Deployment Summary:"
          echo "Function Name: ${{ env.FUNCTION_NAME }}"
          echo "Environment: ${{ env.LAMBDA_NAME }}"
          echo "Runtime: ${{ env.LAMBDA_RUNTIME }}"
          echo "Memory: ${{ env.LAMBDA_MEMORY }}MB"
          echo "Timeout: ${{ env.LAMBDA_TIMEOUT }}s"
          echo "Quarterly Schedule: ${{ steps.create_schedule.outputs.schedule_name }}"
          echo ""
          echo "üîó Next Steps:"
          echo "1. Verify SNS topic ARN is correct"
          echo "2. Test function manually: aws lambda invoke --function-name ${{ env.FUNCTION_NAME }}"
          echo "3. Check CloudWatch logs for execution results"
          echo "4. Enable monthly schedule if needed"
          echo ""
          echo "üìä CloudWatch Logs: /aws/lambda/${{ env.FUNCTION_NAME }}"

      - name: Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up temporary files..."
          rm -f ${{ steps.create_package.outputs.package_name }}
          rm -f test-event.json response.json
          rm -rf lambda-package/
