name: Deploy AWS Inspector Lambda Function.

on:
  push:
    branches: [main]
  
  workflow_dispatch:

env:
  AWS_REGION: eu-west-2
  LAMBDA_NAME: lambda-deployment
  LAMBDA_RUNTIME: python3.12
  LAMBDA_TIMEOUT: 300  # 5 minutes
  LAMBDA_MEMORY: 256   # MB
  FUNCTION_NAME: inspector-ec2-scanner

jobs:
  deploy-lambda:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC }}
          role-session-name: LambdaDeploymentSession
          aws-region: ${{ env.AWS_REGION }}

      - name: Create Lambda Deployment Package
        id: create_package
        run: |
          echo " Creating Lambda deployment package..."

          # Set package name
          PACKAGE_NAME="lambda-deployment.zip"
          
          # Create deployment directory
          mkdir -p lambda-package
          
          # Create the Python script inline
          cat > lambda-package/lambda_function.py << 'EOF'
          import json, boto3, os, base64
          from datetime import datetime, timezone

          SNS_TOPIC_ARN = os.environ["SNS_TOPIC_ARN"]
          SCAN_TYPE = os.environ.get("SCAN_TYPE", "PACKAGE_VULNERABILITY")
          ENVIRONMENT_FILTER = os.environ.get("ENVIRONMENT_FILTER", "")
          REPORTS_BUCKET = os.environ.get("REPORTS_BUCKET", "inspector-reports-bucket")

          sns = boto3.client("sns")
          ec2 = boto3.client("ec2")
          inspector2 = boto3.client("inspector2")

          def _get_instances_and_findings():
              """Get EC2 instances and their Inspector findings."""
              # Discover instances
              filters = [{"Name": "instance-state-name", "Values": ["running"]}]
              if ENVIRONMENT_FILTER:
                  filters.append({"Name": "tag:Environment", "Values": [ENVIRONMENT_FILTER]})
              
              resp = ec2.describe_instances(Filters=filters)
              instances = []
              
              for reservation in resp.get("Reservations", []):
                  for instance in reservation.get("Instances", []):
                      instances.append(instance["InstanceId"])
              
              print(f"Found {len(instances)} running instances")
              
              # Get findings
              try:
                  findings_response = inspector2.list_findings(
                      filterCriteria={'resourceId': [{'comparison': 'EQUALS', 'value': iid} for iid in instances]},
                      maxResults=50
                  )
                  findings = findings_response.get('findings', [])
                  print(f"Retrieved {len(findings)} findings")
              except Exception as e:
                  print(f"Error retrieving findings: {str(e)}")
                  findings = []
              
              return instances, findings

          def _generate_report(scan_id, instances, findings):
              """Generate simple HTML report."""
              # Count findings by severity
              critical = len([f for f in findings if f.get('severity') == 'CRITICAL'])
              high = len([f for f in findings if f.get('severity') == 'HIGH'])
              medium = len([f for f in findings if f.get('severity') == 'MEDIUM'])
              low = len([f for f in findings if f.get('severity') == 'LOW'])
              
              # Risk level
              risk = "HIGH" if critical > 0 else "MEDIUM" if high > 0 else "LOW"
              risk_color = '#dc3545' if risk == 'HIGH' else '#fd7e14' if risk == 'MEDIUM' else '#28a745'
              
              # Top findings
              top_findings = sorted([f for f in findings if f.get('severity') in ['CRITICAL', 'HIGH']], 
                                  key=lambda x: {'CRITICAL': 0, 'HIGH': 1}.get(x.get('severity'), 2))[:5]
              
              findings_html = ""
              for i, finding in enumerate(top_findings, 1):
                  title = finding.get('title', 'Security Issue')[:50]
                  severity = finding.get('severity', 'UNKNOWN')
                  findings_html += f"<li><strong>{severity}:</strong> {title}</li>"
              
              html = f"""<!DOCTYPE html>
          <html><head><title>AWS Inspector Report</title>
          <style>body{{font-family:Arial;margin:20px;}}h1{{color:#2a5298;}}.risk{{color:{risk_color};font-weight:bold;}}</style>
          </head><body>
          <h1>AWS Inspector Security Report</h1>
          <p><strong>Scan ID:</strong> {scan_id}</p>
          <p><strong>Date:</strong> {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}</p>
          <p><strong>Instances Scanned:</strong> {len(instances)}</p>
          <p><strong>Risk Level:</strong> <span class="risk">{risk} RISK</span></p>

          <h2>Findings Summary</h2>
          <ul>
          <li>Critical: {critical}</li>
          <li>High: {high}</li>
          <li>Medium: {medium}</li>
          <li>Low: {low}</li>
          </ul>

          <h2>Top Priority Issues</h2>
          <ul>{findings_html if findings_html else '<li>No critical issues detected</li>'}</ul>

          <p><em>Report generated by AWS Inspector V2</em></p>
          </body></html>"""
              
              print(f"Generated report: {len(html)} characters")
              return base64.b64encode(html.encode('utf-8')).decode('utf-8')

          def _upload_and_notify(report_data, scan_id, instance_count):
              """Upload report to S3 and send notification."""
              scan_name = f"ec2-scan-{datetime.now(timezone.utc).strftime('%Y%m%d-%H%M')}"
              
              # Upload to S3
              try:
                  s3_client = boto3.client('s3')
                  timestamp = datetime.now(timezone.utc).strftime('%Y/%m/%d')
                  s3_key = f"inspector-reports/{timestamp}/{scan_name}.pdf"
                  
                  s3_client.put_object(
                      Bucket=REPORTS_BUCKET,
                      Key=s3_key,
                      Body=report_data,
                      ContentType='application/pdf'
                  )
                  
                  pdf_url = s3_client.generate_presigned_url(
                      'get_object',
                      Params={'Bucket': REPORTS_BUCKET, 'Key': s3_key},
                      ExpiresIn=86400
                  )
                  print(f"Report uploaded: s3://{REPORTS_BUCKET}/{s3_key}")
              except Exception as e:
                  print(f"Upload failed: {str(e)}")
                  pdf_url = None
              
              # Send notification
              message = f"""AWS Inspector V2 scan completed.

          Scan: {scan_name}
          ID: {scan_id}
          Instances: {instance_count}
          Report: {pdf_url if pdf_url else 'Upload failed'}

          Check AWS Console for details."""
              
              sns.publish(
                  TopicArn=SNS_TOPIC_ARN,
                  Subject=f"Inspector Report - {scan_name}",
                  Message=message
              )
              print("Notification sent")

          def lambda_handler(event, context):
              """Main Lambda handler."""
              print("Starting Inspector scan...")
              
              try:
                  # Get instances and findings
                  instances, findings = _get_instances_and_findings()
                  if not instances:
                      print("No instances found")
                      return {"statusCode": 204, "body": "No instances to scan"}
                  
                  # Generate report
                  scan_id = f"inspector-v2-{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S')}"
                  report = _generate_report(scan_id, instances, findings)
                  
                  # Upload and notify
                  _upload_and_notify(report, scan_id, len(instances))
                  
                  print("Scan completed successfully")
                  return {"statusCode": 200, "body": f"Scan completed: {scan_id}"}
                  
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {"statusCode": 500, "body": f"Failed: {str(e)}"}
          EOF    
          
          # Create ZIP package
          cd lambda-package
          zip -r ../$PACKAGE_NAME .
          cd ..
          
          echo " Package created: $PACKAGE_NAME"

          echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT

      - name: Deploy Lambda Function
        run: |
          FUNCTION_NAME="inspector-ec2-scanner"
          PACKAGE_NAME="${{ steps.create_package.outputs.package_name }}"
          
          echo " Deploying Lambda function..."
          
          if aws lambda get-function --function-name $FUNCTION_NAME 2>/dev/null; then
            echo " Updating existing function..."
            
            aws lambda update-function-code \
              --function-name $FUNCTION_NAME \
              --zip-file fileb://$PACKAGE_NAME

            # Wait for code update to complete
            echo " Waiting for code update to complete..."
            aws lambda wait function-updated --function-name $FUNCTION_NAME  
            
            aws lambda update-function-configuration \
              --function-name $FUNCTION_NAME \
              --runtime ${{ env.LAMBDA_RUNTIME }} \
              --timeout ${{ env.LAMBDA_TIMEOUT }} \
              --memory-size ${{ env.LAMBDA_MEMORY }} \
              --environment Variables="{SNS_TOPIC_ARN=${{ secrets.SNS_TOPIC_ARN }},SCAN_TYPE=PACKAGE_VULNERABILITY,ENVIRONMENT_FILTER=staging,REPORTS_BUCKET=${{ secrets.REPORTS_BUCKET }}}"
            
            echo " Function updated"
          else
            echo " Creating new function..."
            
            aws lambda create-function \
              --function-name $FUNCTION_NAME \
              --runtime ${{ env.LAMBDA_RUNTIME }} \
              --role ${{ secrets.LAMBDA_EXECUTION_ROLE_ARN }} \
              --handler lambda_function.lambda_handler \
              --zip-file fileb://$PACKAGE_NAME \
              --timeout ${{ env.LAMBDA_TIMEOUT }} \
              --memory-size ${{ env.LAMBDA_MEMORY }} \
              --environment Variables="{SNS_TOPIC_ARN=${{ secrets.SNS_TOPIC_ARN }},SCAN_TYPE=PACKAGE_VULNERABILITY,ENVIRONMENT_FILTER=staging,REPORTS_BUCKET=${{ secrets.REPORTS_BUCKET }}}" \
              --description "AWS Inspector V2 EC2 Scanner - staging"
            
            echo " Function created"
          fi

      - name: Create EventBridge Schedule (Quarterly - Auto)
        id: create_schedule
        run: |
          SCHEDULE_NAME="inspector-scan-quarterly"
          FUNCTION_NAME="inspector-ec2-scanner"
          
          echo " Setting up quarterly EventBridge schedule..."
          
          # Check if rule already exists
          if aws events describe-rule --name $SCHEDULE_NAME 2>/dev/null; then
            echo " Quarterly schedule already exists: $SCHEDULE_NAME"
          else
            echo " Creating quarterly schedule (auto-enabled)..."
            
            # Get Lambda function ARN
            LAMBDA_ARN=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.FunctionArn' --output text)
            
            # Create schedule (quarterly: January, April, July, October at 2 AM UTC)
            aws events put-rule \
              --name $SCHEDULE_NAME \
              --schedule-expression "cron(0 2 1 1,4,7,10 ? *)" \
              --description "Quarterly AWS Inspector EC2 scan - staging (AUTO)" \
              --state ENABLED
            
            # Add Lambda target
            aws events put-targets \
              --rule $SCHEDULE_NAME \
              --targets "Id"="1","Arn"="$LAMBDA_ARN"
            
            # Add Lambda permission for EventBridge
            aws lambda add-permission \
              --function-name $FUNCTION_NAME \
              --statement-id allow-eventbridge-quarterly \
              --action lambda:InvokeFunction \
              --principal events.amazonaws.com \
              --source-arn "arn:aws:events:${{ env.AWS_REGION }}:$(aws sts get-caller-identity --query Account --output text):rule/$SCHEDULE_NAME" \
              2>/dev/null || echo "Permission already exists"
            
            echo " Quarterly schedule created (ENABLED): $SCHEDULE_NAME"
          fi
          
          echo "schedule_name=$SCHEDULE_NAME" >> $GITHUB_OUTPUT

      - name: Test Lambda Function
        run: |
          echo " Testing Lambda function..."
          
          aws lambda invoke \
            --function-name inspector-ec2-scanner \
            --payload '{}' \
            response.json
          
          echo " Test invocation sent (async)"
          echo " Check CloudWatch logs: aws logs tail /aws/lambda/inspector-ec2-scanner --follow"

      - name: Upload Deployment Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.LAMBDA_NAME }}
          path: |
            ${{ steps.create_package.outputs.package_name }}
          retention-days: 30

      - name: Deployment Summary
        run: |
          echo "ðŸŽ‰ Deployment completed successfully!"
          echo ""
          echo "ðŸ“‹ Deployment Summary:"
          echo "Function Name: ${{ env.FUNCTION_NAME }}"
          echo "Environment: ${{ env.LAMBDA_NAME }}"
          echo "Runtime: ${{ env.LAMBDA_RUNTIME }}"
          echo "Memory: ${{ env.LAMBDA_MEMORY }}MB"
          echo "Timeout: ${{ env.LAMBDA_TIMEOUT }}s"
          echo "Quarterly Schedule: ${{ steps.create_schedule.outputs.schedule_name }}"
          echo ""
          echo "ðŸ”— Next Steps:"
          echo "1. Verify SNS topic ARN is correct"
          echo "2. Test function manually: aws lambda invoke --function-name ${{ env.FUNCTION_NAME }}"
          echo "3. Check CloudWatch logs for execution results"
          echo "4. Enable monthly schedule if needed"
          echo ""
          echo "ðŸ“Š CloudWatch Logs: /aws/lambda/${{ env.FUNCTION_NAME }}"

      - name: Cleanup
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up temporary files..."
          rm -f ${{ steps.create_package.outputs.package_name }}
          rm -f test-event.json response.json
          rm -rf lambda-package/
